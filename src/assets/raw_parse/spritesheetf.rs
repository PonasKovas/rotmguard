// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

// struct Color, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Color(pub [u8; 16]);
impl Default for Color {
	fn default() -> Self {
		Self([0; 16])
	}
}
impl core::fmt::Debug for Color {
	fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
		f.debug_struct("Color")
			.field("r", &self.r())
			.field("g", &self.g())
			.field("b", &self.b())
			.field("a", &self.a())
			.finish()
	}
}

impl flatbuffers::SimpleToVerifyInSlice for Color {}
impl<'a> flatbuffers::Follow<'a> for Color {
	type Inner = &'a Color;
	#[inline]
	unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
		<&'a Color>::follow(buf, loc)
	}
}
impl<'a> flatbuffers::Follow<'a> for &'a Color {
	type Inner = &'a Color;
	#[inline]
	unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
		flatbuffers::follow_cast_ref::<Color>(buf, loc)
	}
}
impl<'b> flatbuffers::Push for Color {
	type Output = Color;
	#[inline]
	unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
		let src = ::core::slice::from_raw_parts(
			self as *const Color as *const u8,
			<Self as flatbuffers::Push>::size(),
		);
		dst.copy_from_slice(src);
	}
	#[inline]
	fn alignment() -> flatbuffers::PushAlignment {
		flatbuffers::PushAlignment::new(4)
	}
}

impl<'a> flatbuffers::Verifiable for Color {
	#[inline]
	fn run_verifier(
		v: &mut flatbuffers::Verifier,
		pos: usize,
	) -> Result<(), flatbuffers::InvalidFlatbuffer> {
		use self::flatbuffers::Verifiable;
		v.in_buffer::<Self>(pos)
	}
}

impl<'a> Color {
	#[allow(clippy::too_many_arguments)]
	pub fn new(r: f32, g: f32, b: f32, a: f32) -> Self {
		let mut s = Self([0; 16]);
		s.set_r(r);
		s.set_g(g);
		s.set_b(b);
		s.set_a(a);
		s
	}

	pub fn r(&self) -> f32 {
		let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
		// Safety:
		// Created from a valid Table for this object
		// Which contains a valid value in this slot
		EndianScalar::from_little_endian(unsafe {
			core::ptr::copy_nonoverlapping(
				self.0[0..].as_ptr(),
				mem.as_mut_ptr() as *mut u8,
				core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
			);
			mem.assume_init()
		})
	}

	pub fn set_r(&mut self, x: f32) {
		let x_le = x.to_little_endian();
		// Safety:
		// Created from a valid Table for this object
		// Which contains a valid value in this slot
		unsafe {
			core::ptr::copy_nonoverlapping(
				&x_le as *const _ as *const u8,
				self.0[0..].as_mut_ptr(),
				core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
			);
		}
	}

	pub fn g(&self) -> f32 {
		let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
		// Safety:
		// Created from a valid Table for this object
		// Which contains a valid value in this slot
		EndianScalar::from_little_endian(unsafe {
			core::ptr::copy_nonoverlapping(
				self.0[4..].as_ptr(),
				mem.as_mut_ptr() as *mut u8,
				core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
			);
			mem.assume_init()
		})
	}

	pub fn set_g(&mut self, x: f32) {
		let x_le = x.to_little_endian();
		// Safety:
		// Created from a valid Table for this object
		// Which contains a valid value in this slot
		unsafe {
			core::ptr::copy_nonoverlapping(
				&x_le as *const _ as *const u8,
				self.0[4..].as_mut_ptr(),
				core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
			);
		}
	}

	pub fn b(&self) -> f32 {
		let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
		// Safety:
		// Created from a valid Table for this object
		// Which contains a valid value in this slot
		EndianScalar::from_little_endian(unsafe {
			core::ptr::copy_nonoverlapping(
				self.0[8..].as_ptr(),
				mem.as_mut_ptr() as *mut u8,
				core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
			);
			mem.assume_init()
		})
	}

	pub fn set_b(&mut self, x: f32) {
		let x_le = x.to_little_endian();
		// Safety:
		// Created from a valid Table for this object
		// Which contains a valid value in this slot
		unsafe {
			core::ptr::copy_nonoverlapping(
				&x_le as *const _ as *const u8,
				self.0[8..].as_mut_ptr(),
				core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
			);
		}
	}

	pub fn a(&self) -> f32 {
		let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
		// Safety:
		// Created from a valid Table for this object
		// Which contains a valid value in this slot
		EndianScalar::from_little_endian(unsafe {
			core::ptr::copy_nonoverlapping(
				self.0[12..].as_ptr(),
				mem.as_mut_ptr() as *mut u8,
				core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
			);
			mem.assume_init()
		})
	}

	pub fn set_a(&mut self, x: f32) {
		let x_le = x.to_little_endian();
		// Safety:
		// Created from a valid Table for this object
		// Which contains a valid value in this slot
		unsafe {
			core::ptr::copy_nonoverlapping(
				&x_le as *const _ as *const u8,
				self.0[12..].as_mut_ptr(),
				core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
			);
		}
	}
}

// struct Position, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Position(pub [u8; 16]);
impl Default for Position {
	fn default() -> Self {
		Self([0; 16])
	}
}
impl core::fmt::Debug for Position {
	fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
		f.debug_struct("Position")
			.field("x", &self.x())
			.field("y", &self.y())
			.field("h", &self.h())
			.field("w", &self.w())
			.finish()
	}
}

impl flatbuffers::SimpleToVerifyInSlice for Position {}
impl<'a> flatbuffers::Follow<'a> for Position {
	type Inner = &'a Position;
	#[inline]
	unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
		<&'a Position>::follow(buf, loc)
	}
}
impl<'a> flatbuffers::Follow<'a> for &'a Position {
	type Inner = &'a Position;
	#[inline]
	unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
		flatbuffers::follow_cast_ref::<Position>(buf, loc)
	}
}
impl<'b> flatbuffers::Push for Position {
	type Output = Position;
	#[inline]
	unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
		let src = ::core::slice::from_raw_parts(
			self as *const Position as *const u8,
			<Self as flatbuffers::Push>::size(),
		);
		dst.copy_from_slice(src);
	}
	#[inline]
	fn alignment() -> flatbuffers::PushAlignment {
		flatbuffers::PushAlignment::new(4)
	}
}

impl<'a> flatbuffers::Verifiable for Position {
	#[inline]
	fn run_verifier(
		v: &mut flatbuffers::Verifier,
		pos: usize,
	) -> Result<(), flatbuffers::InvalidFlatbuffer> {
		use self::flatbuffers::Verifiable;
		v.in_buffer::<Self>(pos)
	}
}

impl<'a> Position {
	#[allow(clippy::too_many_arguments)]
	pub fn new(x: f32, y: f32, h: f32, w: f32) -> Self {
		let mut s = Self([0; 16]);
		s.set_x(x);
		s.set_y(y);
		s.set_h(h);
		s.set_w(w);
		s
	}

	pub fn x(&self) -> f32 {
		let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
		// Safety:
		// Created from a valid Table for this object
		// Which contains a valid value in this slot
		EndianScalar::from_little_endian(unsafe {
			core::ptr::copy_nonoverlapping(
				self.0[0..].as_ptr(),
				mem.as_mut_ptr() as *mut u8,
				core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
			);
			mem.assume_init()
		})
	}

	pub fn set_x(&mut self, x: f32) {
		let x_le = x.to_little_endian();
		// Safety:
		// Created from a valid Table for this object
		// Which contains a valid value in this slot
		unsafe {
			core::ptr::copy_nonoverlapping(
				&x_le as *const _ as *const u8,
				self.0[0..].as_mut_ptr(),
				core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
			);
		}
	}

	pub fn y(&self) -> f32 {
		let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
		// Safety:
		// Created from a valid Table for this object
		// Which contains a valid value in this slot
		EndianScalar::from_little_endian(unsafe {
			core::ptr::copy_nonoverlapping(
				self.0[4..].as_ptr(),
				mem.as_mut_ptr() as *mut u8,
				core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
			);
			mem.assume_init()
		})
	}

	pub fn set_y(&mut self, x: f32) {
		let x_le = x.to_little_endian();
		// Safety:
		// Created from a valid Table for this object
		// Which contains a valid value in this slot
		unsafe {
			core::ptr::copy_nonoverlapping(
				&x_le as *const _ as *const u8,
				self.0[4..].as_mut_ptr(),
				core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
			);
		}
	}

	pub fn h(&self) -> f32 {
		let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
		// Safety:
		// Created from a valid Table for this object
		// Which contains a valid value in this slot
		EndianScalar::from_little_endian(unsafe {
			core::ptr::copy_nonoverlapping(
				self.0[8..].as_ptr(),
				mem.as_mut_ptr() as *mut u8,
				core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
			);
			mem.assume_init()
		})
	}

	pub fn set_h(&mut self, x: f32) {
		let x_le = x.to_little_endian();
		// Safety:
		// Created from a valid Table for this object
		// Which contains a valid value in this slot
		unsafe {
			core::ptr::copy_nonoverlapping(
				&x_le as *const _ as *const u8,
				self.0[8..].as_mut_ptr(),
				core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
			);
		}
	}

	pub fn w(&self) -> f32 {
		let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
		// Safety:
		// Created from a valid Table for this object
		// Which contains a valid value in this slot
		EndianScalar::from_little_endian(unsafe {
			core::ptr::copy_nonoverlapping(
				self.0[12..].as_ptr(),
				mem.as_mut_ptr() as *mut u8,
				core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
			);
			mem.assume_init()
		})
	}

	pub fn set_w(&mut self, x: f32) {
		let x_le = x.to_little_endian();
		// Safety:
		// Created from a valid Table for this object
		// Which contains a valid value in this slot
		unsafe {
			core::ptr::copy_nonoverlapping(
				&x_le as *const _ as *const u8,
				self.0[12..].as_mut_ptr(),
				core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
			);
		}
	}
}

pub enum SpriteOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Sprite<'a> {
	pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Sprite<'a> {
	type Inner = Sprite<'a>;
	#[inline]
	unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
		Self {
			_tab: flatbuffers::Table::new(buf, loc),
		}
	}
}

impl<'a> Sprite<'a> {
	pub const VT_POSITION: flatbuffers::VOffsetT = 4;
	pub const VT_MASK_POSITION: flatbuffers::VOffsetT = 6;
	pub const VT_PADDING: flatbuffers::VOffsetT = 8;
	pub const VT_INDEX: flatbuffers::VOffsetT = 10;
	pub const VT_MOST_COMMON_COLOR: flatbuffers::VOffsetT = 12;
	pub const VT_IS_T: flatbuffers::VOffsetT = 14;
	pub const VT_SPRITE_SHEET_NAME: flatbuffers::VOffsetT = 16;
	pub const VT_ATLAS_ID: flatbuffers::VOffsetT = 18;

	#[inline]
	pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
		Sprite { _tab: table }
	}
	#[allow(unused_mut)]
	pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
		_fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
		args: &'args SpriteArgs<'args>,
	) -> flatbuffers::WIPOffset<Sprite<'bldr>> {
		let mut builder = SpriteBuilder::new(_fbb);
		builder.add_atlas_id(args.atlas_id);
		if let Some(x) = args.sprite_sheet_name {
			builder.add_sprite_sheet_name(x);
		}
		if let Some(x) = args.most_common_color {
			builder.add_most_common_color(x);
		}
		builder.add_index(args.index);
		builder.add_padding(args.padding);
		if let Some(x) = args.mask_position {
			builder.add_mask_position(x);
		}
		if let Some(x) = args.position {
			builder.add_position(x);
		}
		builder.add_is_t(args.is_t);
		builder.finish()
	}

	#[inline]
	pub fn position(&self) -> Option<&'a Position> {
		// Safety:
		// Created from valid Table for this object
		// which contains a valid value in this slot
		unsafe { self._tab.get::<Position>(Sprite::VT_POSITION, None) }
	}
	#[inline]
	pub fn mask_position(&self) -> Option<&'a Position> {
		// Safety:
		// Created from valid Table for this object
		// which contains a valid value in this slot
		unsafe { self._tab.get::<Position>(Sprite::VT_MASK_POSITION, None) }
	}
	#[inline]
	pub fn padding(&self) -> i32 {
		// Safety:
		// Created from valid Table for this object
		// which contains a valid value in this slot
		unsafe { self._tab.get::<i32>(Sprite::VT_PADDING, Some(0)).unwrap() }
	}
	#[inline]
	pub fn index(&self) -> i32 {
		// Safety:
		// Created from valid Table for this object
		// which contains a valid value in this slot
		unsafe { self._tab.get::<i32>(Sprite::VT_INDEX, Some(0)).unwrap() }
	}
	#[inline]
	pub fn most_common_color(&self) -> Option<&'a Color> {
		// Safety:
		// Created from valid Table for this object
		// which contains a valid value in this slot
		unsafe { self._tab.get::<Color>(Sprite::VT_MOST_COMMON_COLOR, None) }
	}
	#[inline]
	pub fn is_t(&self) -> bool {
		// Safety:
		// Created from valid Table for this object
		// which contains a valid value in this slot
		unsafe { self._tab.get::<bool>(Sprite::VT_IS_T, Some(false)).unwrap() }
	}
	#[inline]
	pub fn sprite_sheet_name(&self) -> Option<&'a str> {
		// Safety:
		// Created from valid Table for this object
		// which contains a valid value in this slot
		unsafe {
			self._tab
				.get::<flatbuffers::ForwardsUOffset<&str>>(Sprite::VT_SPRITE_SHEET_NAME, None)
		}
	}
	#[inline]
	pub fn atlas_id(&self) -> i64 {
		// Safety:
		// Created from valid Table for this object
		// which contains a valid value in this slot
		unsafe { self._tab.get::<i64>(Sprite::VT_ATLAS_ID, Some(0)).unwrap() }
	}
}

impl flatbuffers::Verifiable for Sprite<'_> {
	#[inline]
	fn run_verifier(
		v: &mut flatbuffers::Verifier,
		pos: usize,
	) -> Result<(), flatbuffers::InvalidFlatbuffer> {
		use self::flatbuffers::Verifiable;
		v.visit_table(pos)?
			.visit_field::<Position>("position", Self::VT_POSITION, false)?
			.visit_field::<Position>("mask_position", Self::VT_MASK_POSITION, false)?
			.visit_field::<i32>("padding", Self::VT_PADDING, false)?
			.visit_field::<i32>("index", Self::VT_INDEX, false)?
			.visit_field::<Color>("most_common_color", Self::VT_MOST_COMMON_COLOR, false)?
			.visit_field::<bool>("is_t", Self::VT_IS_T, false)?
			.visit_field::<flatbuffers::ForwardsUOffset<&str>>(
				"sprite_sheet_name",
				Self::VT_SPRITE_SHEET_NAME,
				false,
			)?
			.visit_field::<i64>("atlas_id", Self::VT_ATLAS_ID, false)?
			.finish();
		Ok(())
	}
}
pub struct SpriteArgs<'a> {
	pub position: Option<&'a Position>,
	pub mask_position: Option<&'a Position>,
	pub padding: i32,
	pub index: i32,
	pub most_common_color: Option<&'a Color>,
	pub is_t: bool,
	pub sprite_sheet_name: Option<flatbuffers::WIPOffset<&'a str>>,
	pub atlas_id: i64,
}
impl<'a> Default for SpriteArgs<'a> {
	#[inline]
	fn default() -> Self {
		SpriteArgs {
			position: None,
			mask_position: None,
			padding: 0,
			index: 0,
			most_common_color: None,
			is_t: false,
			sprite_sheet_name: None,
			atlas_id: 0,
		}
	}
}

pub struct SpriteBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
	fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
	start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SpriteBuilder<'a, 'b, A> {
	#[inline]
	pub fn add_position(&mut self, position: &Position) {
		self.fbb_
			.push_slot_always::<&Position>(Sprite::VT_POSITION, position);
	}
	#[inline]
	pub fn add_mask_position(&mut self, mask_position: &Position) {
		self.fbb_
			.push_slot_always::<&Position>(Sprite::VT_MASK_POSITION, mask_position);
	}
	#[inline]
	pub fn add_padding(&mut self, padding: i32) {
		self.fbb_.push_slot::<i32>(Sprite::VT_PADDING, padding, 0);
	}
	#[inline]
	pub fn add_index(&mut self, index: i32) {
		self.fbb_.push_slot::<i32>(Sprite::VT_INDEX, index, 0);
	}
	#[inline]
	pub fn add_most_common_color(&mut self, most_common_color: &Color) {
		self.fbb_
			.push_slot_always::<&Color>(Sprite::VT_MOST_COMMON_COLOR, most_common_color);
	}
	#[inline]
	pub fn add_is_t(&mut self, is_t: bool) {
		self.fbb_.push_slot::<bool>(Sprite::VT_IS_T, is_t, false);
	}
	#[inline]
	pub fn add_sprite_sheet_name(&mut self, sprite_sheet_name: flatbuffers::WIPOffset<&'b str>) {
		self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
			Sprite::VT_SPRITE_SHEET_NAME,
			sprite_sheet_name,
		);
	}
	#[inline]
	pub fn add_atlas_id(&mut self, atlas_id: i64) {
		self.fbb_.push_slot::<i64>(Sprite::VT_ATLAS_ID, atlas_id, 0);
	}
	#[inline]
	pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SpriteBuilder<'a, 'b, A> {
		let start = _fbb.start_table();
		SpriteBuilder {
			fbb_: _fbb,
			start_: start,
		}
	}
	#[inline]
	pub fn finish(self) -> flatbuffers::WIPOffset<Sprite<'a>> {
		let o = self.fbb_.end_table(self.start_);
		flatbuffers::WIPOffset::new(o.value())
	}
}

impl core::fmt::Debug for Sprite<'_> {
	fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
		let mut ds = f.debug_struct("Sprite");
		ds.field("position", &self.position());
		ds.field("mask_position", &self.mask_position());
		ds.field("padding", &self.padding());
		ds.field("index", &self.index());
		ds.field("most_common_color", &self.most_common_color());
		ds.field("is_t", &self.is_t());
		ds.field("sprite_sheet_name", &self.sprite_sheet_name());
		ds.field("atlas_id", &self.atlas_id());
		ds.finish()
	}
}
pub enum SpriteSheetOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SpriteSheet<'a> {
	pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SpriteSheet<'a> {
	type Inner = SpriteSheet<'a>;
	#[inline]
	unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
		Self {
			_tab: flatbuffers::Table::new(buf, loc),
		}
	}
}

impl<'a> SpriteSheet<'a> {
	pub const VT_NAME: flatbuffers::VOffsetT = 4;
	pub const VT_ATLAS_ID: flatbuffers::VOffsetT = 6;
	pub const VT_SPRITES: flatbuffers::VOffsetT = 8;

	#[inline]
	pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
		SpriteSheet { _tab: table }
	}
	#[allow(unused_mut)]
	pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
		_fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
		args: &'args SpriteSheetArgs<'args>,
	) -> flatbuffers::WIPOffset<SpriteSheet<'bldr>> {
		let mut builder = SpriteSheetBuilder::new(_fbb);
		builder.add_atlas_id(args.atlas_id);
		if let Some(x) = args.sprites {
			builder.add_sprites(x);
		}
		if let Some(x) = args.name {
			builder.add_name(x);
		}
		builder.finish()
	}

	#[inline]
	pub fn name(&self) -> Option<&'a str> {
		// Safety:
		// Created from valid Table for this object
		// which contains a valid value in this slot
		unsafe {
			self._tab
				.get::<flatbuffers::ForwardsUOffset<&str>>(SpriteSheet::VT_NAME, None)
		}
	}
	#[inline]
	pub fn atlas_id(&self) -> i64 {
		// Safety:
		// Created from valid Table for this object
		// which contains a valid value in this slot
		unsafe {
			self._tab
				.get::<i64>(SpriteSheet::VT_ATLAS_ID, Some(0))
				.unwrap()
		}
	}
	#[inline]
	pub fn sprites(
		&self,
	) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Sprite<'a>>>> {
		// Safety:
		// Created from valid Table for this object
		// which contains a valid value in this slot
		unsafe {
			self._tab.get::<flatbuffers::ForwardsUOffset<
				flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Sprite>>,
			>>(SpriteSheet::VT_SPRITES, None)
		}
	}
}

impl flatbuffers::Verifiable for SpriteSheet<'_> {
	#[inline]
	fn run_verifier(
		v: &mut flatbuffers::Verifier,
		pos: usize,
	) -> Result<(), flatbuffers::InvalidFlatbuffer> {
		use self::flatbuffers::Verifiable;
		v.visit_table(pos)?
			.visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
			.visit_field::<i64>("atlas_id", Self::VT_ATLAS_ID, false)?
			.visit_field::<flatbuffers::ForwardsUOffset<
				flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Sprite>>,
			>>("sprites", Self::VT_SPRITES, false)?
			.finish();
		Ok(())
	}
}
pub struct SpriteSheetArgs<'a> {
	pub name: Option<flatbuffers::WIPOffset<&'a str>>,
	pub atlas_id: i64,
	pub sprites: Option<
		flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Sprite<'a>>>>,
	>,
}
impl<'a> Default for SpriteSheetArgs<'a> {
	#[inline]
	fn default() -> Self {
		SpriteSheetArgs {
			name: None,
			atlas_id: 0,
			sprites: None,
		}
	}
}

pub struct SpriteSheetBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
	fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
	start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SpriteSheetBuilder<'a, 'b, A> {
	#[inline]
	pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
		self.fbb_
			.push_slot_always::<flatbuffers::WIPOffset<_>>(SpriteSheet::VT_NAME, name);
	}
	#[inline]
	pub fn add_atlas_id(&mut self, atlas_id: i64) {
		self.fbb_
			.push_slot::<i64>(SpriteSheet::VT_ATLAS_ID, atlas_id, 0);
	}
	#[inline]
	pub fn add_sprites(
		&mut self,
		sprites: flatbuffers::WIPOffset<
			flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Sprite<'b>>>,
		>,
	) {
		self.fbb_
			.push_slot_always::<flatbuffers::WIPOffset<_>>(SpriteSheet::VT_SPRITES, sprites);
	}
	#[inline]
	pub fn new(
		_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
	) -> SpriteSheetBuilder<'a, 'b, A> {
		let start = _fbb.start_table();
		SpriteSheetBuilder {
			fbb_: _fbb,
			start_: start,
		}
	}
	#[inline]
	pub fn finish(self) -> flatbuffers::WIPOffset<SpriteSheet<'a>> {
		let o = self.fbb_.end_table(self.start_);
		flatbuffers::WIPOffset::new(o.value())
	}
}

impl core::fmt::Debug for SpriteSheet<'_> {
	fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
		let mut ds = f.debug_struct("SpriteSheet");
		ds.field("name", &self.name());
		ds.field("atlas_id", &self.atlas_id());
		ds.field("sprites", &self.sprites());
		ds.finish()
	}
}
pub enum AnimatedSpriteOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AnimatedSprite<'a> {
	pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AnimatedSprite<'a> {
	type Inner = AnimatedSprite<'a>;
	#[inline]
	unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
		Self {
			_tab: flatbuffers::Table::new(buf, loc),
		}
	}
}

impl<'a> AnimatedSprite<'a> {
	pub const VT_NAME: flatbuffers::VOffsetT = 4;
	pub const VT_INDEX: flatbuffers::VOffsetT = 6;
	pub const VT_SET: flatbuffers::VOffsetT = 8;
	pub const VT_DIRECTION: flatbuffers::VOffsetT = 10;
	pub const VT_ACTION: flatbuffers::VOffsetT = 12;
	pub const VT_SPRITE: flatbuffers::VOffsetT = 14;

	#[inline]
	pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
		AnimatedSprite { _tab: table }
	}
	#[allow(unused_mut)]
	pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
		_fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
		args: &'args AnimatedSpriteArgs<'args>,
	) -> flatbuffers::WIPOffset<AnimatedSprite<'bldr>> {
		let mut builder = AnimatedSpriteBuilder::new(_fbb);
		if let Some(x) = args.sprite {
			builder.add_sprite(x);
		}
		builder.add_action(args.action);
		builder.add_direction(args.direction);
		builder.add_set(args.set);
		builder.add_index(args.index);
		if let Some(x) = args.name {
			builder.add_name(x);
		}
		builder.finish()
	}

	#[inline]
	pub fn name(&self) -> Option<&'a str> {
		// Safety:
		// Created from valid Table for this object
		// which contains a valid value in this slot
		unsafe {
			self._tab
				.get::<flatbuffers::ForwardsUOffset<&str>>(AnimatedSprite::VT_NAME, None)
		}
	}
	#[inline]
	pub fn index(&self) -> u32 {
		// Safety:
		// Created from valid Table for this object
		// which contains a valid value in this slot
		unsafe {
			self._tab
				.get::<u32>(AnimatedSprite::VT_INDEX, Some(0))
				.unwrap()
		}
	}
	#[inline]
	pub fn set(&self) -> i32 {
		// Safety:
		// Created from valid Table for this object
		// which contains a valid value in this slot
		unsafe {
			self._tab
				.get::<i32>(AnimatedSprite::VT_SET, Some(0))
				.unwrap()
		}
	}
	#[inline]
	pub fn direction(&self) -> u32 {
		// Safety:
		// Created from valid Table for this object
		// which contains a valid value in this slot
		unsafe {
			self._tab
				.get::<u32>(AnimatedSprite::VT_DIRECTION, Some(0))
				.unwrap()
		}
	}
	#[inline]
	pub fn action(&self) -> u32 {
		// Safety:
		// Created from valid Table for this object
		// which contains a valid value in this slot
		unsafe {
			self._tab
				.get::<u32>(AnimatedSprite::VT_ACTION, Some(0))
				.unwrap()
		}
	}
	#[inline]
	pub fn sprite(&self) -> Option<Sprite<'a>> {
		// Safety:
		// Created from valid Table for this object
		// which contains a valid value in this slot
		unsafe {
			self._tab
				.get::<flatbuffers::ForwardsUOffset<Sprite>>(AnimatedSprite::VT_SPRITE, None)
		}
	}
}

impl flatbuffers::Verifiable for AnimatedSprite<'_> {
	#[inline]
	fn run_verifier(
		v: &mut flatbuffers::Verifier,
		pos: usize,
	) -> Result<(), flatbuffers::InvalidFlatbuffer> {
		use self::flatbuffers::Verifiable;
		v.visit_table(pos)?
			.visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
			.visit_field::<u32>("index", Self::VT_INDEX, false)?
			.visit_field::<i32>("set", Self::VT_SET, false)?
			.visit_field::<u32>("direction", Self::VT_DIRECTION, false)?
			.visit_field::<u32>("action", Self::VT_ACTION, false)?
			.visit_field::<flatbuffers::ForwardsUOffset<Sprite>>("sprite", Self::VT_SPRITE, false)?
			.finish();
		Ok(())
	}
}
pub struct AnimatedSpriteArgs<'a> {
	pub name: Option<flatbuffers::WIPOffset<&'a str>>,
	pub index: u32,
	pub set: i32,
	pub direction: u32,
	pub action: u32,
	pub sprite: Option<flatbuffers::WIPOffset<Sprite<'a>>>,
}
impl<'a> Default for AnimatedSpriteArgs<'a> {
	#[inline]
	fn default() -> Self {
		AnimatedSpriteArgs {
			name: None,
			index: 0,
			set: 0,
			direction: 0,
			action: 0,
			sprite: None,
		}
	}
}

pub struct AnimatedSpriteBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
	fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
	start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AnimatedSpriteBuilder<'a, 'b, A> {
	#[inline]
	pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
		self.fbb_
			.push_slot_always::<flatbuffers::WIPOffset<_>>(AnimatedSprite::VT_NAME, name);
	}
	#[inline]
	pub fn add_index(&mut self, index: u32) {
		self.fbb_
			.push_slot::<u32>(AnimatedSprite::VT_INDEX, index, 0);
	}
	#[inline]
	pub fn add_set(&mut self, set: i32) {
		self.fbb_.push_slot::<i32>(AnimatedSprite::VT_SET, set, 0);
	}
	#[inline]
	pub fn add_direction(&mut self, direction: u32) {
		self.fbb_
			.push_slot::<u32>(AnimatedSprite::VT_DIRECTION, direction, 0);
	}
	#[inline]
	pub fn add_action(&mut self, action: u32) {
		self.fbb_
			.push_slot::<u32>(AnimatedSprite::VT_ACTION, action, 0);
	}
	#[inline]
	pub fn add_sprite(&mut self, sprite: flatbuffers::WIPOffset<Sprite<'b>>) {
		self.fbb_
			.push_slot_always::<flatbuffers::WIPOffset<Sprite>>(AnimatedSprite::VT_SPRITE, sprite);
	}
	#[inline]
	pub fn new(
		_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
	) -> AnimatedSpriteBuilder<'a, 'b, A> {
		let start = _fbb.start_table();
		AnimatedSpriteBuilder {
			fbb_: _fbb,
			start_: start,
		}
	}
	#[inline]
	pub fn finish(self) -> flatbuffers::WIPOffset<AnimatedSprite<'a>> {
		let o = self.fbb_.end_table(self.start_);
		flatbuffers::WIPOffset::new(o.value())
	}
}

impl core::fmt::Debug for AnimatedSprite<'_> {
	fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
		let mut ds = f.debug_struct("AnimatedSprite");
		ds.field("name", &self.name());
		ds.field("index", &self.index());
		ds.field("set", &self.set());
		ds.field("direction", &self.direction());
		ds.field("action", &self.action());
		ds.field("sprite", &self.sprite());
		ds.finish()
	}
}
pub enum SpriteSheetRootOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SpriteSheetRoot<'a> {
	pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SpriteSheetRoot<'a> {
	type Inner = SpriteSheetRoot<'a>;
	#[inline]
	unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
		Self {
			_tab: flatbuffers::Table::new(buf, loc),
		}
	}
}

impl<'a> SpriteSheetRoot<'a> {
	pub const VT_SPRITES: flatbuffers::VOffsetT = 4;
	pub const VT_ANIMATED_SPRITES: flatbuffers::VOffsetT = 6;

	#[inline]
	pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
		SpriteSheetRoot { _tab: table }
	}
	#[allow(unused_mut)]
	pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
		_fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
		args: &'args SpriteSheetRootArgs<'args>,
	) -> flatbuffers::WIPOffset<SpriteSheetRoot<'bldr>> {
		let mut builder = SpriteSheetRootBuilder::new(_fbb);
		if let Some(x) = args.animated_sprites {
			builder.add_animated_sprites(x);
		}
		if let Some(x) = args.sprites {
			builder.add_sprites(x);
		}
		builder.finish()
	}

	#[inline]
	pub fn sprites(
		&self,
	) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SpriteSheet<'a>>>> {
		// Safety:
		// Created from valid Table for this object
		// which contains a valid value in this slot
		unsafe {
			self._tab.get::<flatbuffers::ForwardsUOffset<
				flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SpriteSheet>>,
			>>(SpriteSheetRoot::VT_SPRITES, None)
		}
	}
	#[inline]
	pub fn animated_sprites(
		&self,
	) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimatedSprite<'a>>>> {
		// Safety:
		// Created from valid Table for this object
		// which contains a valid value in this slot
		unsafe {
			self._tab.get::<flatbuffers::ForwardsUOffset<
				flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimatedSprite>>,
			>>(SpriteSheetRoot::VT_ANIMATED_SPRITES, None)
		}
	}
}

impl flatbuffers::Verifiable for SpriteSheetRoot<'_> {
	#[inline]
	fn run_verifier(
		v: &mut flatbuffers::Verifier,
		pos: usize,
	) -> Result<(), flatbuffers::InvalidFlatbuffer> {
		use self::flatbuffers::Verifiable;
		v.visit_table(pos)?
			.visit_field::<flatbuffers::ForwardsUOffset<
				flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SpriteSheet>>,
			>>("sprites", Self::VT_SPRITES, false)?
			.visit_field::<flatbuffers::ForwardsUOffset<
				flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AnimatedSprite>>,
			>>("animated_sprites", Self::VT_ANIMATED_SPRITES, false)?
			.finish();
		Ok(())
	}
}
pub struct SpriteSheetRootArgs<'a> {
	pub sprites: Option<
		flatbuffers::WIPOffset<
			flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SpriteSheet<'a>>>,
		>,
	>,
	pub animated_sprites: Option<
		flatbuffers::WIPOffset<
			flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AnimatedSprite<'a>>>,
		>,
	>,
}
impl<'a> Default for SpriteSheetRootArgs<'a> {
	#[inline]
	fn default() -> Self {
		SpriteSheetRootArgs {
			sprites: None,
			animated_sprites: None,
		}
	}
}

pub struct SpriteSheetRootBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
	fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
	start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SpriteSheetRootBuilder<'a, 'b, A> {
	#[inline]
	pub fn add_sprites(
		&mut self,
		sprites: flatbuffers::WIPOffset<
			flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<SpriteSheet<'b>>>,
		>,
	) {
		self.fbb_
			.push_slot_always::<flatbuffers::WIPOffset<_>>(SpriteSheetRoot::VT_SPRITES, sprites);
	}
	#[inline]
	pub fn add_animated_sprites(
		&mut self,
		animated_sprites: flatbuffers::WIPOffset<
			flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<AnimatedSprite<'b>>>,
		>,
	) {
		self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
			SpriteSheetRoot::VT_ANIMATED_SPRITES,
			animated_sprites,
		);
	}
	#[inline]
	pub fn new(
		_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
	) -> SpriteSheetRootBuilder<'a, 'b, A> {
		let start = _fbb.start_table();
		SpriteSheetRootBuilder {
			fbb_: _fbb,
			start_: start,
		}
	}
	#[inline]
	pub fn finish(self) -> flatbuffers::WIPOffset<SpriteSheetRoot<'a>> {
		let o = self.fbb_.end_table(self.start_);
		flatbuffers::WIPOffset::new(o.value())
	}
}

impl core::fmt::Debug for SpriteSheetRoot<'_> {
	fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
		let mut ds = f.debug_struct("SpriteSheetRoot");
		ds.field("sprites", &self.sprites());
		ds.field("animated_sprites", &self.animated_sprites());
		ds.finish()
	}
}
#[inline]
/// Verifies that a buffer of bytes contains a `SpriteSheetRoot`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_sprite_sheet_root_unchecked`.
pub fn root_as_sprite_sheet_root(
	buf: &[u8],
) -> Result<SpriteSheetRoot, flatbuffers::InvalidFlatbuffer> {
	flatbuffers::root::<SpriteSheetRoot>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `SpriteSheetRoot` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_sprite_sheet_root_unchecked`.
pub fn size_prefixed_root_as_sprite_sheet_root(
	buf: &[u8],
) -> Result<SpriteSheetRoot, flatbuffers::InvalidFlatbuffer> {
	flatbuffers::size_prefixed_root::<SpriteSheetRoot>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `SpriteSheetRoot` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_sprite_sheet_root_unchecked`.
pub fn root_as_sprite_sheet_root_with_opts<'b, 'o>(
	opts: &'o flatbuffers::VerifierOptions,
	buf: &'b [u8],
) -> Result<SpriteSheetRoot<'b>, flatbuffers::InvalidFlatbuffer> {
	flatbuffers::root_with_opts::<SpriteSheetRoot<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `SpriteSheetRoot` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_sprite_sheet_root_unchecked`.
pub fn size_prefixed_root_as_sprite_sheet_root_with_opts<'b, 'o>(
	opts: &'o flatbuffers::VerifierOptions,
	buf: &'b [u8],
) -> Result<SpriteSheetRoot<'b>, flatbuffers::InvalidFlatbuffer> {
	flatbuffers::size_prefixed_root_with_opts::<SpriteSheetRoot<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a SpriteSheetRoot and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `SpriteSheetRoot`.
pub unsafe fn root_as_sprite_sheet_root_unchecked(buf: &[u8]) -> SpriteSheetRoot {
	flatbuffers::root_unchecked::<SpriteSheetRoot>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed SpriteSheetRoot and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `SpriteSheetRoot`.
pub unsafe fn size_prefixed_root_as_sprite_sheet_root_unchecked(buf: &[u8]) -> SpriteSheetRoot {
	flatbuffers::size_prefixed_root_unchecked::<SpriteSheetRoot>(buf)
}
#[inline]
pub fn finish_sprite_sheet_root_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
	fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
	root: flatbuffers::WIPOffset<SpriteSheetRoot<'a>>,
) {
	fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_sprite_sheet_root_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
	fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
	root: flatbuffers::WIPOffset<SpriteSheetRoot<'a>>,
) {
	fbb.finish_size_prefixed(root, None);
}
